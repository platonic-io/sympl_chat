# """Chat 3.0.0

# Chat is a Symbiont Assembly™ smart contract that implements private messaging. A smart contract (generally referred to
# as “a contract”) is a code module implementing the logic of a decentralized application. Symbiont smart contract modules
# are written in a domain-specific language (DSL) and executed in a virtual machine within each node. Assembly’s smart
# contract language is fully deterministic and has built-in support for true end-to-end transaction privacy (via secure
# channels).

# Chat allows users (represented as "key aliases") to send messages to each other confidentially in rooms (implemented via
# secure channels).

# The code is arranged in four sections: models, events, public API, and implementations.

# Models are described by Schema declarations, which define how application data is stored.

# Events are also described by Schemas.

# The public API is defined by @clientside functions, which are accessed by node API clients.

# Functions marked @executable are called by transactions posted to the distributed log, and run on the network as a
# whole.

# A primary feature of the Symbiont language is its ability to support logic that runs both on a single node, as well as
# logic that runs on the network as a whole. The former logic is called @clientside logic, while the latter is called
# @executable logic. However, in a decentralized network, there is no client/server system. These terms are just used to
# represent local vs. global operations, implemented as code in a single module.

# Notably, all changes to a node’s state must be made by running "executable" logic, in order to maintain consistency in
# node state. "clientside" logic is used for read-only queries of node state, though it may have the side-effect of
# constructing and broadcasting a transaction to the network which then in turn triggers "executable" logic. Each smart
# contract module has isolated storage associated with it, used to store the shared state associated with the logic of the
# module.

# Copyright © 2019 Symbiont.io, all rights reserved.

# Proprietary and confidential. Unauthorized copying via any medium is strictly prohibited.

# """

VERSION : str = "8-3.0.0"

#################
# public models #
#################


# a single message sent by a user through a secure channel
schema Message:
    @indexed
    message_id: Identifier  # identifies the message in storage
    @indexed
    sender: KeyAlias  # the key alias that sent the message
    body: str  # the content of the message
    timestamp: Timestamp  # the time of the message

# a single room, implemented as a secure channel
schema Room:
    @indexed
    channel: ChannelName  # the secure channel ID that implements the room
    @indexed
    name: str  # the human-readable name of the room
    is_deleted: bool  # to support restoration, deleted rooms are flagged, not expunged
    members: List[KeyAlias]  # a list of the key aliases that have access to the room
    owners: List[KeyAlias]   # a list of key aliases that are 'owners' of the room (this should always be a subset of 'members', these people functiona as admins)

##########
# events #
##########

schema CreateRoomEvent:
    room: Room

schema DeleteRoomEvent:
    room: Room

schema RestoreRoomEvent:
    room: Room

schema InviteToRoomEvent:
    room: Room
    inviter: KeyAlias
    invitee: KeyAlias

schema RemoveFromRoomEvent:
    room: Room
    remover: KeyAlias
    removee: KeyAlias

schema SendMessageEvent:
    room: Room
    message: Message

schema PromoteToOwnerEvent:
    room: Room
    promoter: KeyAlias
    promotee: KeyAlias

schema DemoteOwnerEvent:
    room: Room
    demoter: KeyAlias
    demotee: KeyAlias

# ##############
# # public API #
# ##############


@clientside
def create_room(room_name: str) -> None:
    """Creates a room with the given name, and returns a CreateRoomEvent.
    Other room operations require a `room_channel: ChannelName`, which is part of the returned `Room` object.
    """
    return _create_room(room_name)


@clientside
def delete_room(room_channel: ChannelName) -> None:
    """Deletes a room.
    This does not expunge the underlying data, but flags the room as deleted so that it can be restored later if needed.
    Membership is frozen at the time of deletion, and only members of the deleted room can restore it.
    """
    return _delete_room(room_channel)


@clientside
def restore_room(room_channel: ChannelName) -> None:
    """Restores a previously deleted room.
    Membership is frozen at the time of deletion, and only members of the deleted room can restore it."""
    return _restore_room(room_channel)


@clientside
def invite_to_room(room_channel: ChannelName, new_member: KeyAlias) -> None:
    """Invites a new member to a room.
    The caller must already be part of the room.
    """
    return _invite_to_room(room_channel, new_member)


@clientside
def remove_from_room(room_channel: ChannelName, member_to_remove: KeyAlias) -> None:
    """Removes a member from a room.
    A removed member will no longer be able to send or receive messages, add or remove members, nor delete or restore
    the room.
    A member cannot remove themselves if they are the last one in the room.
    """
    return _remove_from_room(room_channel, member_to_remove)


@clientside
def get_messages(room_channel: ChannelName) -> List[Message]:
    """Returns all messages in the room, sorted by timestamp."""
    return _get_messages(room_channel)


@clientside
def get_rooms() -> List[Room]:
    """Returns all rooms that the caller has access to, sorted by name.
    It is possible to belong to multiple rooms with the same name. However they will always be disambiguated by their
    channel name, which is globally unique.
    """
    return _get_rooms()


@clientside
def send_message(room_channel: ChannelName, message: str) -> None:
    """Sends a message to a room.
    Messages can be between 1 and 4000 characters long. Messages cannot contain null bytes.
    """
    return _send_message(room_channel, message)


@clientside
def promote_to_owner(room_channel: ChannelName, member: KeyAlias) -> None:
    """Promotes a current member of a room to owner
    Promotions to owner of the room 
    """
    return _promote_to_owner(room_channel, member)

@clientside
def demote_owner(room_channel: ChannelName, owner: KeyAlias) -> None:
    """Demotes the owner of a room.
    Only works if there is at least one other owner
    """
    return _demote_owner(room_channel, owner)

# # ###################
# # # implementations #
# # ###################

@public
def _get_room(room_channel: ChannelName) -> Room:
    room = cvm.storage.get(room_channel, RoomStatic, Identifier('room'))
    if isinstance(room,  None):
        room_channel_str : str = room_channel
        cvm.error(f"Room for channel {room_channel_str} not found.")
    return room

@public
def _guard_input(input_description: str, input_: str) -> None:
    if input_ == '':
        cvm.error(f"{input_description} cannot be empty.")
    nb = chr(0)
    if isinstance(nb, None):
       cvm.error("Cannot compute null byte")
    if nb in input_:
        cvm.error(f"{input_description} cannot contain null byte.")
    if len(input_) > 4000:
        cvm.error(f"{input_description} cannot be longer than 4000 characters.")

@public_clientside
def _create_room(room_name: str) -> None:
    _guard_input("Room name", room_name)
    room_channel = cvm.new_channel('RID')
    with PostTxArgs(room_channel):
        _create_room_execute(room_name, room_channel)
    cvm.job_start()

@executable
def _create_room_execute(room_name: str, room_channel: ChannelName) -> None:
    _guard_input("Room name", room_name)
    room = cvm.storage.get(room_channel, RoomStatic, Identifier('room'))
    if isinstance(room, None):
        room = Room(channel=room_channel, name=room_name, is_deleted=False, members=[cvm.tx.key_alias], owners=[cvm.tx.key_alias])
        cvm.storage.put(Identifier('room'), room)
        create_room_event = CreateRoomEvent(room=room)
        cvm.create_event('CreateRoomEvent', std.json(create_room_event))
        cvm.job_complete(std.json(create_room_event))
    else:
        room_channel_str : str = room_channel
        cvm.error(f'Room {room_channel_str} already exists.')

@public_clientside
def _delete_room(room_channel: ChannelName) -> None:
    room = _get_room(room_channel)
    if room.is_deleted:
        room_channel_str : str = room_channel
        cvm.error(f'Room {room_channel_str} already deleted.')
    with PostTxArgs(room_channel):
        _delete_room_execute(room_channel)
    cvm.job_start()


@executable
def _delete_room_execute(room_channel: ChannelName) -> None:
    room = _get_room(room_channel)
    members = room.members

    if not std.contains_using(members, cvm.tx.key_alias, _str_eq):
        not_a_member : str = cvm.tx.key_alias
        cvm.error(f'Member {not_a_member} does not belong to the room. Operation denied.')

    room.is_deleted = True
    cvm.storage.put(Identifier('room'), room)
    delete_room_event = DeleteRoomEvent(room=room)
    cvm.create_event('DeleteRoomEvent', std.json(delete_room_event))
    cvm.job_complete(std.json(delete_room_event))

@public_clientside
def _restore_room(room_channel: ChannelName) -> None:
    room = _get_room(room_channel)
    if not room.is_deleted:
        room_channel_str : str = room_channel
        cvm.error(f'Room {room_channel_str} already active.')
    with PostTxArgs(room_channel):
        _restore_room_execute(room_channel)
    cvm.job_start()


@executable
def _restore_room_execute(room_channel: ChannelName) -> None:
    room = _get_room(room_channel)
    members = room.members

    if not std.contains_using(members, cvm.tx.key_alias, _str_eq):
        not_a_member : str = cvm.tx.key_alias
        cvm.error(f'Member {not_a_member} does not belong to the room. Operation denied.')

    if not room.is_deleted:
        room_channel_str : str = room_channel
        cvm.error(f'Room {room_channel_str} already active.')
    room.is_deleted = False
    cvm.storage.put(Identifier('room'), room)
    restore_room_event = RestoreRoomEvent(room=room)
    cvm.create_event('RestoreRoomEvent', std.json(restore_room_event))
    cvm.job_complete(std.json(restore_room_event))

@public_clientside
def _invite_to_room(room_channel: ChannelName, new_member: KeyAlias) -> None:
    room = _get_room(room_channel)
    members = room.members
    if std.contains_using(members, new_member, _str_eq):
        new_member_str : str = new_member
        room_channel_str : str = room_channel
        cvm.error(f'Member {new_member_str} already in room {room_channel_str}.')
    #cvm.add_owner(room_channel, new_member)
    cvm.send_key(room_channel, new_member)
    with PostTxArgs(room_channel):
        _invite_to_room_execute(room_channel, new_member)
    cvm.job_start()


@executable
def _invite_to_room_execute(room_channel: ChannelName, new_member: KeyAlias) -> None:
    room = _get_room(room_channel)
    members = room.members

    if not std.contains_using(members, cvm.tx.key_alias, _str_eq):
        not_a_member : str = cvm.tx.key_alias
        cvm.error(f'Member {not_a_member} does not belong to the room. Operation denied.')

    room.members = room.members + [new_member]
    cvm.storage.put(Identifier('room'), room)
    invite_to_room_event = InviteToRoomEvent(room=room, inviter=cvm.tx.key_alias, invitee=new_member)
    cvm.create_event('InviteToRoomEvent', std.json(invite_to_room_event))
    cvm.job_complete(std.json(invite_to_room_event))

@public_clientside
def _remove_from_room(room_channel: ChannelName, member_to_remove: KeyAlias) -> None:
    room = _get_room(room_channel)
    mrs : str = member_to_remove
    if mrs == cvm.tx.key_alias:
        cvm.error(f"Cannot remove self from room.")
    members = room.members
    if not std.contains_using(members, member_to_remove, _str_eq):
        member_to_remove_str : str = member_to_remove
        room_channel_str : str = room_channel
        cvm.error(f'Member {member_to_remove_str} not in room {room_channel_str}.')
    with PostTxArgs(room_channel):
        _remove_from_room_execute(room_channel, member_to_remove)
    #cvm.remove_owner(room_channel, member_to_remove)
    cvm.rotate_key(room_channel)
    updated_members = room.members
    for member in updated_members:
        mx : str = member
        if mx != member_to_remove:
            cvm.send_key(room_channel, member)
    cvm.job_start()


@executable
def _remove_from_room_execute(room_channel: ChannelName, member_to_remove: KeyAlias) -> None:
    room = _get_room(room_channel)
    members = room.members

    if not std.contains_using(members, cvm.tx.key_alias, _str_eq):
        not_a_member : str = cvm.tx.key_alias
        cvm.error(f'Member {not_a_member} does not belong to the room. Operation denied.')

    if not std.contains_using(members, member_to_remove, _str_eq):
        member_to_remove_str : str = member_to_remove
        cvm.error(f'Member {member_to_remove_str} already removed. This may have happened due to a concurrent operation.')

    # room.members-remove(member_to_remove)
    mtr: str = member_to_remove
    rmx : List[KeyAlias] = [m for m in room.members if mtr != m]
    room.members = rmx
    cvm.storage.put(Identifier('room'), room)
    remove_from_room_event = RemoveFromRoomEvent(room=room, remover=cvm.tx.key_alias, removee=member_to_remove)
    cvm.create_event('RemoveFromRoomEvent', std.json(remove_from_room_event))
    cvm.job_complete(std.json(remove_from_room_event))


@public_clientside
def _send_message(room_channel: ChannelName, message: str) -> None:
    room = _get_room(room_channel)
    if room.is_deleted:
        room_channel_str : str = room_channel
        cvm.error(f'Room {room_channel_str} has been deleted. Cannot send message.')
    _guard_input("Message", message)
    with PostTxArgs(room_channel):
        _send_message_execute(room_channel, message)
    cvm.job_start()


@executable
def _send_message_execute(room_channel: ChannelName, message: str) -> None:
    room = _get_room(room_channel)
    members = room.members

    if not std.contains_using(members, cvm.tx.key_alias, _str_eq):
        not_a_member : str = cvm.tx.key_alias
        cvm.error(f'Member {not_a_member} does not belong to the room. Operation denied.')

    if room.is_deleted:
        room_channel_str : str = room_channel
        cvm.error(f'Room {room_channel_str} has been deleted. Cannot send message.')
    _guard_input("Message", message)
    message_id = cvm.generate_id('MID')
    new_message = Message(message_id=message_id, sender=cvm.tx.key_alias, body=message, timestamp=cvm.tx.timestamp)
    cvm.storage.put(new_message.message_id, new_message)
    send_message_event = SendMessageEvent(room=room, message=new_message)
    cvm.create_event('SendMessageEvent', std.json(message_id))
    cvm.job_complete(std.json(message_id))

@public_clientside
def _get_messages(room_channel: ChannelName) -> List[Message]:
    # check that the room exists and is accessible
    room = _get_room(room_channel)
    room_channel_str : str = room_channel
    if room.is_deleted:
        room_channel_str : str = room_channel
        cvm.error(f'Room {room_channel_str} has been deleted. Cannot get messages.')
    messages = cvm.storage.query(MessageStatic).in_channel(room_channel).values()
    def compare(lhs: Message, rhs: Message) -> bool:
        lt : int = lhs.timestamp
        return lt < rhs.timestamp
    return std.sort_by(messages, compare)

@public
def _get_rooms() -> List[Room]:
    rooms : List[Room] = [r for r in cvm.storage.query(RoomStatic).values() if not r.is_deleted]
    def compare(lhs: Room, rhs: Room) -> bool:
        ln : str = lhs.name
        lc : str = lhs.channel
        if (ln < rhs.name):
            return True
        elif (ln == rhs.name):
            return lc < rhs.channel
        else:
            return False

    return std.sort_by(rooms, compare)

@public_clientside
def _promote_to_owner(room_channel: ChannelName, member: KeyAlias) -> None:
    room = _get_room(room_channel)
    
    #run the checks and error out if there is an issue
    check_result: str = promote_to_owner_checks(member, cvm.tx.key_alias, room)
    if check_result != '':
        cvm.error(check_result)

    #This will promote the member to 'owner' of the secure channel
    cvm.add_owner(room_channel, member)

    #This function allows the @executable function
    #to have access the the channel with which you
    #are attempting to write
    with PostTxArgs(room_channel):
        _promote_to_owner_execute(room_channel, member)

@executable
def _promote_to_owner_execute(room_channel: ChannelName, member: KeyAlias) -> PromoteToOwnerEvent:
    room = _get_room(room_channel)
    
    #run the checks, and error out if there is an issue
    #this is performed on both the executable and clientside sides
    #because a malicious KA and Node Administrator could directly run
    #any executable function 
    check_result: str = promote_to_owner_checks(member, cvm.tx.key_alias, room)
    if check_result != '':
        cvm.error(check_result)

    #update the owners list in storage
    room.owners = room.owners + [member]
    cvm.storage.put(Identifier('room'), room)

    #create an event for owner promotion, and return the event data
    promote_to_owner_event = PromoteToOwnerEvent(room=room, promoter=cvm.tx.key_alias, promotee=member)
    cvm.create_event('PromoteToOwnerEvent', std.json(promote_to_owner_event))
    return promote_to_owner_event

def promote_to_owner_checks(member: KeyAlias, caller: KeyAlias, room: Room) -> str:
    #This function performs the permission checks for the promote to owner logic
    #it takes a member, caller, and a room channel, and ensures that the caller KA
    #is allowed to promote the member KA to an owner

    room_channel = room.channel

    #ensure that the member to promote is actually in the room
    if not std.contains_using(room.members, member, _str_eq):
        member_str : str = member
        room_channel_str : str = room_channel
        return f"Member {member_str} is not in room {room_channel_str}."
    
    #check to ensure a member is not already an owner
    if std.contains_using(room.owners, member, _str_eq):
        member_str : str = member
        room_channel_str : str = room_channel
        return f"Member {member_str} is already an owner of room {room_channel_str}."

    #check to ensure that a room is not deleted
    if room.is_deleted:
        room_channel_str : str = room_channel
        return f'Room {room_channel_str} has been deleted. Cannot promote anyone'

    #ensure that the calling key alias is an owner of the room, and is allowed
    #to promote others to owner
    if not std.contains_using(room.owners, caller, _str_eq):
        not_an_owner : str = caller
        return f'{not_an_owner} is not an owner of the room. Operation denied.'
    
    return ''

@public_clientside
def _demote_owner(room_channel: ChannelName, owner: KeyAlias) -> None:
    
    room = _get_room(room_channel)

    check_result : str = demote_owner_checks(owner, cvm.tx.key_alias, room)
    if check_result != '':
        cvm.error(check_result)

    #This will remove the 'owner' from the secure channel
    cvm.remove_owner(room_channel, owner)
    
    #This function allows the @executable function
    #to have access the the channel with which you
    #are attempting to write
    with PostTxArgs(room_channel):
        _demote_owner_execute(room_channel, owner)

@executable
def _demote_owner_execute(room_channel: ChannelName, owner: KeyAlias) -> DemoteOwnerEvent:
    room = _get_room(room_channel)
    
    check_result : str = demote_owner_checks(owner, cvm.tx.key_alias, room)
    if check_result != '':
        cvm.error(check_result)

    #update the owners list in storage
    otr : str = owner
    new_owners_list : List[KeyAlias] = [o for o in room.owners if otr != o]
    room.owners = new_owners_list
    cvm.storage.put(Identifier('room'), room)

    #create an event for owner promotion, and return the event data
    demote_owner_event = DemoteOwnerEvent(room=room, demoter=cvm.tx.key_alias, demotee=owner)
    cvm.create_event('DemoteOwnerEvent', std.json(demote_owner_event))
    return demote_owner_event

def demote_owner_checks(owner: KeyAlias, caller: KeyAlias, room: Room) -> str:
    #This function performs the permission checks for the demote owner logic
    #it takes an owner, caller, and a room channel, and ensures that the caller KA
    #is allowed to demote the owner KA
    room_channel =  room.channel
    
    #check to ensure the owner is already a member of a room
    if not std.contains_using(room.members, owner, _str_eq):
        owner_str : str = owner
        room_channel_str : str = room_channel
        return f'{owner_str} is not a member of room {room_channel_str}. Please invite them first.'

    #check to ensure the owner to demote is actually an owner
    if not std.contains_using(room.owners, owner, _str_eq):
        owner_str : str = owner
        room_channel_str : str = room_channel
        return f'{owner_str} is not an owner of room {room_channel_str}.'
    
    #check to ensure that a room is not deleted
    if room.is_deleted:
        room_channel_str : str = room_channel
        return f'Room {room_channel_str} has been deleted. Cannot promote anyone'

    #ensure that the calling key alias is an owner of the room, and is allowed
    #to promote others to owner
    if not std.contains_using(room.owners, caller, _str_eq):
        not_an_owner : str = caller
        return f'{not_an_owner} is not an owner of the room. Operation denied.'

    return ""

def _str_eq(str1 : str, str2: str) -> bool:
    return str1 == str2
